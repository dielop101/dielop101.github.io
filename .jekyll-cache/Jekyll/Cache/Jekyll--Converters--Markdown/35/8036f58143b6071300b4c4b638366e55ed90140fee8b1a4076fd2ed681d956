I"Ü4<p>Es una realidad que los microservicios estÃ¡n entre nosotros y han venido para quedarse, pero como todas las arquitecturas, tienen sus pros y sus contras. En el punto de contras, entre otras, vemos el aumento de complejidad que no se tenÃ­a tan en exceso en la implementaciÃ³n de otras arquitecturas: el tracing distribuÃ­do.</p>

<p>Es por ello que no han tardado en aparecer soluciones para tratar de hacer mÃ¡s llevadero esta problemÃ¡tica que plantean los microservicios. Por una parte, <a href="https://opentracing.io/" target="_blank">OpenTracing</a> se perfila como el estÃ¡ndar a seguir, y <a href="https://www.jaegertracing.io/" target="_blank">Jaeger</a> como la implementaciÃ³n <i>open source</i> del mercado.</p>

<p>En este post, tratarÃ© de sintetizar los conceptos clave acerca de OpenTracing y su implementaciÃ³n a travÃ©s de Jaeger para .NET.</p>

<div align="center">
  <img src="/images/OpentracingJaeger/Jaeger-icon.png" />
</div>

<h2 id="opentracing">OpenTracing</h2>
<h3 id="introducciÃ³n">IntroducciÃ³n</h3>
<p>De la mano de Google, OpenTracing se ofrece como un estÃ¡ndar asociado a la trazabilidad distribuÃ­da. Aunque parezca que OpenTracing es un estÃ¡ndar nuevo, lleva existiendo y usÃ¡ndose en arquitecturas complejas basadas en servicios desde hace un tiempo atrÃ¡s, pero no ha dado el salto a popularizarse hasta encontrar su espacio en los microservicios.</p>

<h3 id="conceptos">Conceptos</h3>
<p>Cabe destacar que OpenTracing no se apoya en ningÃºn lenguaje de programaciÃ³n especÃ­fico, es decir, tiene sentido bajo cualquier lenguaje. A efectos prÃ¡cticos, esto se traduce en ofrecer al desarrollador una interfaz con una serie de funcionalidades para cumplir su estÃ¡ndar. El listado de los lenguajes de programaciÃ³n soportados se puede consultar <a href="https://github.com/opentracing" target="_blank">aquÃ­</a>. En nuestro caso, elegiremos la interfaz que se ofrece para <a href="https://github.com/opentracing/opentracing-csharp" target="_blank">C#</a>. La implementaciÃ³n de esta interfaz recaerÃ¡ en manos del desarrollador.</p>

<h4 id="span">Span</h4>
<p>Se define como la representaciÃ³n de una unidad lÃ³gica de trabajo, pudiendo ser desde una llamada http hasta un acceso a base de datos. La parte clave de este concepto es que tiene referencia a otros spans, construyÃ©ndose a travÃ©s de esta informaciÃ³n un flujo temporal, es decir, una traza.</p>

<p>Contiene los siguientes campos:</p>
<ul>
<li>Nombre.</li>
<li>Timespan de inicio y de fin.</li>
<li>Referencias a otros spans.</li>
<li><b>SpanContext.</b></li>
<li>Conjunto de <b>tags</b> (clave/valor).</li>
<li>Conjunto de <b>logs</b> (clave/valor).</li>
</ul>

<p>En Opentracing, se entienden dos tipos de referencias entre spans:</p>
<ul>
<li><b>ChildOf</b>: el span padre depende del span hijo (sÃ­ncrono). El span padre siempre esperarÃ­a respuesta del span hijo. Por ejemplo, una peticiÃ³n http la cual esperamos su respuesta.</li>
<li><b>FollowsFrom</b>: el span padre no depende del span hijo (asÃ­ncrono). El span padre podrÃ­a terminar antes que el hijo. Por ejemplo, en mensajerÃ­a asÃ­ncrona.</li>
</ul>

<p>OpenTracing proveerÃ¡ una interfaz ISpan capaz de realizar todas las operaciones necesarias para obtener y alterar estos campos segÃºn las necesidades del desarrollador.</p>

<h5 id="spancontext">SpanContext</h5>
<p>Contenido dentro del Span, encontramos el SpanContext. Representa el estado del span que se suministrarÃ¡ a hijos y a otros procesos que lo requieran. En esta entidad, podemos encontrar el identificador asociado al span y el identificador de la traza en la que el span tiene contexto. AdemÃ¡s, contiene una lista de <b>baggage items</b>, entendiÃ©ndose como un listado clave/valor de informaciÃ³n extra que pueda servirnos para identificar al span.</p>

<p>De nuevo, OpenTracing proveerÃ¡ una interfaz ISpanContext para gestionarlos, aunque el nÃºcleo fuerte de operaciones se podrÃ¡n realizar a travÃ©s de la funcionalidad que ofrece la interfaz ISpan.</p>

<h5 id="tags-y-logs">Tags y logs</h5>
<p>Los <b>tags</b> sirven para anotar en el span consultas, filtros y de mÃ¡s informaciÃ³n necesaria para comprender la traza. En cambio, los <b>logs</b> son Ãºtiles para capturar mensajes de log siguiendo una lÃ­nea temporal, facilitando entre otras cosas el debug de la ejecuciÃ³n del span.</p>

<p>Existe una convenciÃ³n de nombrado de las claves que podemos encontrar <a href="https://github.com/opentracing/specification/blob/master/semantic_conventions.md" target="_blank">aquÃ­</a>.</p>

<h5 id="ejemplo-de-span">Ejemplo de span</h5>

<pre><code class="language-code">    t=0            operation name: db_query               t=x

Tags:
- db.instance:"customers"
- db.statement:"SELECT * FROM mytable WHERE foo='bar'"
- peer.address:"mysql://127.0.0.1:3306/customers"

Logs:
- message:"Can't connect to mysql server on '127.0.0.1'(10061)"

SpanContext:
- trace_id:"abc123"
- span_id:"xyz789"
- Baggage Items:
  - special_id:"vsid1738"
</code></pre>

<h4 id="tracer">Tracer</h4>
<p>Es el elemento encargado de la creaciÃ³n de spans. AdemÃ¡s, tiene la capacidad de propagar a travÃ©s de operaciones de inyecciÃ³n y extracciÃ³n la informaciÃ³n de spans entre diferentes procesos.</p>

<p>Todas estas operaciones las proveerÃ¡ OpenTracing a travÃ©s de la interfaz ITracer.</p>

<div align="center">
  <img src="/images/OpentracingJaeger/Trace-inject-extract.png" />
</div>

<h3 id="dag">DAG</h3>
<p>Como se intuye a raÃ­z de los conceptos, OpenTracing establece su base en que una traza sea un <i>GrÃ¡fico AcÃ­clico Dirigido (DAG)</i> de spans. En el siguiente ejemplo, vemos una traza de 8 spans:</p>
<pre><code class="language-code">        [Span A]  â†â†â†(la raÃ­z)
            |
     +------+------+
     |             |
 [Span B]      [Span C] â†â†â†(Span C es un `ChildOf` Span A)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]
                                       â†‘
                                       â†‘
                                       â†‘
                         (Span G `FollowsFrom` Span F)

</code></pre>

<p>TambiÃ©n lo podemos ver como una lÃ­nea temporal:</p>

<pre><code class="language-code">â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“â€“â€“â€“â€“â€“â€“|â€“&gt; tiempo

 [Span AÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·]
   [Span BÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·]
      [Span DÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·]
    [Span CÂ·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·]
         [Span EÂ·Â·Â·Â·Â·Â·Â·]        [Span FÂ·Â·] [Span GÂ·Â·] [Span HÂ·Â·]
</code></pre>

<h2 id="jaeger">Jaeger</h2>

<h3 id="definiciÃ³n">DefiniciÃ³n</h3>
<p>Jaeger se ofrece como una implementaciÃ³n al estÃ¡ndar de OpenTracing, luego su principal objetivo serÃ¡ monitorizar sistemas distribuÃ­dos complejos. La implementaciÃ³n, definida y utilizada hoy dÃ­a en los sistemas distribuÃ­dos de Uber, se basa en <a href="https://research.google/pubs/pub36356/" target="_blank">Dapper</a> y <a href="https://zipkin.io/" target="_blank">OpenZipkin</a>.</p>

<p>La principal caracterÃ­stica que difiere de otras implementaciones es que las trazas no se envÃ­an al recolector, sino que es un agente el encargado de recolectar esta informaciÃ³n. En la siguiente imagen podemos ver la arquitectura:</p>
<div align="center">
  <img src="/images/OpentracingJaeger/Opentracing-Jaeger-arq.png" />
</div>

<h3 id="all-in-one">All-in-one</h3>
<p>Como hemos visto en la arquitectura, Jaeger se basa en 5 componentes: cliente, agente, recolector, query, y Jaeger UI, con un componente adicional de almacenamiento de memoria.</p>

<p>La librerÃ­a cliente se implementarÃ¡ en cada servicio, pero para levantar el resto de los servicios que forman la infraestructura, Jaeger nos ofrece un ejecutable que denomina <b>all-in-one</b>.</p>

<h2 id="ejemplo-prÃ¡ctico">Ejemplo prÃ¡ctico</h2>

<h3 id="opentracing-en-acciÃ³n">OpenTracing en acciÃ³n</h3>
<p>Para nuestro ejemplo, vamos a empezar con una aplicaciÃ³n de escritorio. Comenzaremos importando las interfaces de OpenTracing:</p>
<div align="center">
  <img src="/images/OpentracingJaeger/OpenTracing-01.png" />
</div>

<p>Lo primero de todo serÃ¡ obtener a travÃ©s del constructor una traza de tipo <b>ITracer</b>. El cÃ³mo se implemente de momento no nos importa. Sabremos que alguien nos va a inyectar la implementaciÃ³n cuando se requiera. Tendremos una propiedad privada de sÃ³lo lectura <b>_trace</b> encargada de instanciarse en el constructor y que se usarÃ¡ donde la clase lo necesite.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">OpenTracing</span><span class="p">;</span>	<span class="c1">//1</span>

<span class="k">namespace</span> <span class="nn">OpenTraceProgram</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ITracer</span> <span class="n">_tracer</span><span class="p">;</span>	<span class="c1">//2</span>

        <span class="k">public</span> <span class="nf">Program</span><span class="p">(</span><span class="n">ITracer</span> <span class="n">tracer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_tracer</span> <span class="p">=</span> <span class="n">tracer</span><span class="p">;</span>	<span class="c1">//3</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Una vez tenemos la traza, ya podemos crear nuestro primer <b>span</b>.</p>

<p>Vamos a crear una funciÃ³n <i>HelloWord()</i> que Ãºnicamente saque por consola el mensaje <i>Hello World!</i>. En ella, iniciaremos un espacio donde vivirÃ¡ el <i>scope</i> del span a travÃ©s de la instancia _tracer. Debemos indicar al crear el span el nombre que va a tener. Si indicamos <i>finishSpanOnDispose = true</i>, cuando se haga el <i>dispose</i> del objeto scope, se finalizarÃ¡ el span (luego no serÃ¡ necesario que hagamos un <i>scope.Span.Finish()</i>). Vamos a registrar en el log del span que el mensaje â€œ<i>Hello World!</i>â€ se ha mostrado correctamente.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">HelloWord</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">IScope</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">_tracer</span><span class="p">.</span><span class="nf">BuildSpan</span><span class="p">(</span><span class="s">"HelloWord Method"</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">StartActive</span><span class="p">(</span><span class="n">finishSpanOnDispose</span><span class="p">:</span> <span class="k">true</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
                <span class="n">scope</span><span class="p">.</span><span class="n">Span</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hello World done"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Con sÃ³lo esto, ya tenemos en juego un pequeÃ±o <b>DAG</b> que constarÃ¡ de un Ãºnico span.</p>

<p>Para probar nuestra funciÃ³n, vamos a instanciar la clase <i>Program</i> y vamos a inyectar una implementaciÃ³n. Tenemos 2 opciones:</p>
<ol>
<li>Inyectar GlobalTracer: es una instancia que nos provÃ© OpenTracing para poder realizar pruebas sin necesidad de que el tracing influya. Es un objeto sin funcionalidad. TendrÃ­amos algo tal que asÃ­:
</li>

```csharp
        static void Main(string[] args)
        {
            var tracer = GlobalTracer.Instance;
            new Program(tracer).HelloWord();
        }
```

<li></li>

</ol>

<h3 id="jaeger-en-acciÃ³n">Jaeger en acciÃ³n</h3>

<h2 id="enlaces-de-interÃ©s">Enlaces de interÃ©s</h2>
<p>https://opentracing.io/docs/overview/spans/
https://opentracing.io/specification/
https://www.paradigmadigital.com/dev/trazabilidad-distribuida-con-opentracing-y-jaeger/
https://www.jaegertracing.io/docs/1.16/</p>
:ET