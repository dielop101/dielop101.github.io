I"3<p>Es una realidad que los microservicios están entre nosotros y han venido para quedarse, pero como todas las arquitecturas, tienen sus pros y sus contras. En el punto de contras, entre otras, vemos el aumento de complejidad que no se tenía tan en exceso en la implementación de otras arquitecturas: el tracing distribuído.</p>

<p>Es por ello que no han tardado en aparecer soluciones para tratar de hacer más llevadero esta problemática que plantean los microservicios. Por una parte, <a href="https://opentracing.io/" target="_blank">OpenTracing</a> se perfila como el estándar a seguir, y <a href="https://www.jaegertracing.io/" target="_blank">Jaeger</a> como la implementación <i>open source</i> del mercado.</p>

<p>En este post, trataré de sintetizar los conceptos clave acerca de OpenTracing y su implementación a través de Jaeger para .NET.</p>

<div align="center">
  <img src="/images/OpentracingJaeger/Jaeger-icon.png" />
</div>

<h2 id="opentracing">OpenTracing</h2>
<h3 id="introducción">Introducción</h3>
<p>De la mano de Google, OpenTracing se ofrece como un estándar asociado a la trazabilidad distribuída. Aunque parezca que OpenTracing es un estándar nuevo, lleva existiendo y usándose en arquitecturas complejas basadas en servicios desde hace un tiempo atrás, pero no ha dado el salto a popularizarse hasta encontrar su espacio en los microservicios.</p>

<h3 id="conceptos">Conceptos</h3>
<p>Cabe destacar que OpenTracing no se apoya en ningún lenguaje de programación específico, es decir, tiene sentido bajo cualquier lenguaje. A efectos prácticos, esto se traduce en ofrecer al desarrollador una interfaz con una serie de funcionalidades para cumplir su estándar. El listado de los lenguajes de programación soportados se puede consultar <a href="https://github.com/opentracing" target="_blank">aquí</a>. En nuestro caso, elegiremos la interfaz que se ofrece para <a href="https://github.com/opentracing/opentracing-csharp" target="_blank">C#</a>. La implementación de esta interfaz recaerá en manos del desarrollador.</p>

<h4 id="span">Span</h4>
<p>Se define como la representación de una unidad lógica de trabajo, pudiendo ser desde una llamada http hasta un acceso a base de datos. La parte clave de este concepto es que tiene referencia a otros spans, construyéndose a través de esta información un flujo temporal, es decir, una traza.</p>

<p>Contiene los siguientes campos:</p>
<ul>
<li>Nombre.</li>
<li>Timespan de inicio y de fin.</li>
<li>Referencias a otros spans.</li>
<li><b>SpanContext.</b></li>
<li>Conjunto de <b>tags</b> (clave/valor).</li>
<li>Conjunto de <b>logs</b> (clave/valor).</li>
</ul>

<p>En Opentracing, se entienden dos tipos de referencias entre spans:</p>
<ul>
<li><b>ChildOf</b>: el span padre depende del span hijo (síncrono). El span padre siempre esperaría respuesta del span hijo. Por ejemplo, una petición http la cual esperamos su respuesta.</li>
<li><b>FollowsFrom</b>: el span padre no depende del span hijo (asíncrono). El span padre podría terminar antes que el hijo. Por ejemplo, en mensajería asíncrona.</li>
</ul>

<p>OpenTracing proveerá una interfaz ISpan capaz de realizar todas las operaciones necesarias para obtener y alterar estos campos según las necesidades del desarrollador.</p>

<h5 id="spancontext">SpanContext</h5>
<p>Contenido dentro del Span, encontramos el SpanContext. Representa el estado del span que se suministrará a hijos y a otros procesos que lo requieran. En esta entidad, podemos encontrar el identificador asociado al span y el identificador de la traza en la que el span tiene contexto. Además, contiene una lista de <b>baggage items</b>, entendiéndose como un listado clave/valor de información extra que pueda servirnos para identificar al span.</p>

<p>De nuevo, OpenTracing proveerá una interfaz ISpanContext para gestionarlos, aunque el núcleo fuerte de operaciones se podrán realizar a través de la funcionalidad que ofrece la interfaz ISpan.</p>

<h5 id="tags-y-logs">Tags y logs</h5>
<p>Los <b>tags</b> sirven para anotar en el span consultas, filtros y de más información necesaria para comprender la traza. En cambio, los <b>logs</b> son útiles para capturar mensajes de log siguiendo una línea temporal, facilitando entre otras cosas el debug de la ejecución del span.</p>

<p>Existe una convención de nombrado de las claves que podemos encontrar <a href="https://github.com/opentracing/specification/blob/master/semantic_conventions.md" target="_blank">aquí</a>.</p>

<h5 id="ejemplo-de-span">Ejemplo de span</h5>

<pre><code class="language-code">    t=0            operation name: db_query               t=x

Tags:
- db.instance:"customers"
- db.statement:"SELECT * FROM mytable WHERE foo='bar'"
- peer.address:"mysql://127.0.0.1:3306/customers"

Logs:
- message:"Can't connect to mysql server on '127.0.0.1'(10061)"

SpanContext:
- trace_id:"abc123"
- span_id:"xyz789"
- Baggage Items:
  - special_id:"vsid1738"
</code></pre>

<h4 id="tracer">Tracer</h4>
<p>Es el elemento encargado de la creación de spans. Además, tiene la capacidad de propagar a través de operaciones de inyección y extracción la información de spans entre diferentes procesos.</p>

<p>Todas estas operaciones las proveerá OpenTracing a través de la interfaz ITracer.</p>

<div align="center">
  <img src="/images/OpentracingJaeger/Trace-inject-extract.png" />
</div>

<h3 id="dag">DAG</h3>
<p>Como se intuye a raíz de los conceptos, OpenTracing establece su base en que una traza sea un <i>Gráfico Acíclico Dirigido (DAG)</i> de spans. En el siguiente ejemplo, vemos una traza de 8 spans:</p>
<pre><code class="language-code">        [Span A]  ←←←(la raíz)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C es un `ChildOf` Span A)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G `FollowsFrom` Span F)

</code></pre>

<p>También lo podemos ver como una línea temporal:</p>

<pre><code class="language-code">––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; tiempo

 [Span A···················································]
   [Span B··············································]
      [Span D··········································]
    [Span C········································]
         [Span E·······]        [Span F··] [Span G··] [Span H··]
</code></pre>

<h2 id="jaeger">Jaeger</h2>

<h3 id="definición">Definición</h3>
<p>Jaeger se ofrece como una implementación al estándar de OpenTracing, luego su principal objetivo será monitorizar sistemas distribuídos complejos. La implementación, definida y utilizada hoy día en los sistemas distribuídos de Uber, se basa en <a href="https://research.google/pubs/pub36356/" target="_blank">Dapper</a> y <a href="https://zipkin.io/" target="_blank">OpenZipkin</a>.</p>

<p>La principal característica que difiere de otras implementaciones es que las trazas no se envían al recolector, sino que es un agente el encargado de recolectar esta información. En la siguiente imagen podemos ver la arquitectura:</p>
<div align="center">
  <img src="/images/OpentracingJaeger/Opentracing-Jaeger-arq.png" />
</div>

<h3 id="all-in-one">All-in-one</h3>
<p>Como hemos visto en la arquitectura, Jaeger se basa en 5 componentes: cliente, agente, recolector, query, y Jaeger UI, con un componente adicional de almacenamiento de memoria.</p>

<p>La librería cliente se implementará en cada servicio, pero para levantar el resto de los servicios que forman la infraestructura, Jaeger nos ofrece un ejecutable que denomina <b>all-in-one</b>.</p>

<h2 id="ejemplo-práctico">Ejemplo práctico</h2>

<h3 id="opentracing-en-acción">OpenTracing en acción</h3>
<p>Para nuestro ejemplo, vamos a empezar con una aplicación de escritorio. Comenzaremos importando las interfaces de OpenTracing:</p>
<div align="center">
  <img src="/images/OpentracingJaeger/OpenTracing-01.png" />
</div>

<p>Lo primero de todo será obtener a través del constructor una traza de tipo <b>ITracer</b>. El cómo se implemente de momento no nos importa. Sabremos que alguien nos va a inyectar la implementación cuando se requiera. Tendremos una propiedad privada de sólo lectura <b>_trace</b> encargada de instanciarse en el constructor y que se usará donde la clase lo necesite.</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">OpenTracing</span><span class="p">;</span>	<span class="c1">//1</span>

<span class="k">namespace</span> <span class="nn">OpenTraceProgram</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ITracer</span> <span class="n">_tracer</span><span class="p">;</span>	<span class="c1">//2</span>

        <span class="k">public</span> <span class="nf">Program</span><span class="p">(</span><span class="n">ITracer</span> <span class="n">tracer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_tracer</span> <span class="p">=</span> <span class="n">tracer</span><span class="p">;</span>	<span class="c1">//3</span>
        <span class="p">}</span>

        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Una vez tenemos la traza, ya podemos crear nuestro primer <b>span</b>.</p>

<p>Vamos a crear una función <i>HelloWord()</i> que únicamente saque por consola el mensaje <i>Hello World!</i>. En ella, iniciaremos un espacio donde vivirá el <i>scope</i> del span a través de la instancia _tracer. Debemos indicar al crear el span el nombre que va a tener. Si indicamos <i>finishSpanOnDispose = true</i>, cuando se haga el <i>dispose</i> del objeto scope, se finalizará el span (luego no será necesario que hagamos un <i>scope.Span.Finish()</i>). Vamos a registrar en el log del span que el mensaje “<i>Hello World!</i>” se ha mostrado correctamente.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">HelloWord</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">IScope</span> <span class="n">scope</span> <span class="p">=</span> <span class="n">_tracer</span><span class="p">.</span><span class="nf">BuildSpan</span><span class="p">(</span><span class="s">"HelloWord Method"</span><span class="p">)</span>
                <span class="p">.</span><span class="nf">StartActive</span><span class="p">(</span><span class="n">finishSpanOnDispose</span><span class="p">:</span> <span class="k">true</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">);</span>
                <span class="n">scope</span><span class="p">.</span><span class="n">Span</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="s">"Hello World done"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Con sólo esto, ya tenemos en juego un pequeño <b>DAG</b> que constará de un único span.</p>

<p>Para probar nuestra función, vamos a instanciar la clase <i>Program</i></p>

<h3 id="jaeger-en-acción">Jaeger en acción</h3>

<h2 id="enlaces-de-interés">Enlaces de interés</h2>
<p>https://opentracing.io/docs/overview/spans/
https://opentracing.io/specification/
https://www.paradigmadigital.com/dev/trazabilidad-distribuida-con-opentracing-y-jaeger/
https://www.jaegertracing.io/docs/1.16/</p>
:ET